---
language: terraform
stack: GCP/AWS + GitHub Actions CI/CD
min_version: "1.5"
last_updated: 2026-02-10
token_estimate: ~2600
---

# Terraform Conventions

Opinionated Terraform conventions for GCP/AWS infrastructure with CI/CD via GitHub Actions.

## Tooling

| Tool | Purpose | Command |
|------|---------|---------|
| **Terraform 1.5+** | Infrastructure as Code (or OpenTofu) | `terraform plan`, `terraform apply` |
| **tflint** | Linting | `tflint --init`, `tflint` |
| **tfsec** | Security scanning | `tfsec .` |
| **terraform-docs** | Auto-generated docs | `terraform-docs markdown .` |
| **pre-commit** | Git hooks for validation | `pre-commit run --all-files` |

## Pre-commit Config

```yaml
repos:
  - repo: https://github.com/antonbabenko/pre-commit-terraform
    rev: v1.96.0
    hooks:
      - id: terraform_fmt
      - id: terraform_validate
      - id: terraform_docs
      - id: terraform_tflint
      - id: terraform_tfsec
```

## Module Structure

```
module/
├── main.tf          # Primary resources
├── variables.tf     # Input variables (all with descriptions + defaults)
├── outputs.tf       # Output values
├── versions.tf      # Provider + Terraform version constraints
└── README.md        # Auto-generated by terraform-docs
```

- Use `this` as the default resource name within modules
- One resource per logical group
- Separate files for large resource groups (e.g., `iam.tf`, `networking.tf`)

## State Management

### GCS Backend (GCP)

```hcl
terraform {
  backend "gcs" {
    bucket = "myapp-terraform-state"
    prefix = "environments/prod"
  }
}
```

### S3 Backend (AWS)

```hcl
terraform {
  backend "s3" {
    bucket         = "myapp-terraform-state"
    key            = "environments/prod/terraform.tfstate"
    region         = "us-east-1"
    encrypt        = true
    dynamodb_table = "terraform-locks"
  }
}
```

- State prefix per environment: `prefix = "environments/<env>"`
- Remote state federation for cross-stack references:

```hcl
data "terraform_remote_state" "network" {
  backend = "gcs"
  config = {
    bucket = "myapp-terraform-state"
    prefix = "environments/prod/network"
  }
}
```

## Environment Strategy

- `terraform.tfvars.example` checked in (no secrets)
- `environments/dev.tfvars` and `environments/prod.tfvars`
- Conditional logic: `var.environment == "prod" ? value_a : value_b`
- Never commit actual tfvars with secrets

```hcl
variable "environment" {
  description = "Deployment environment"
  type        = string
  validation {
    condition     = contains(["dev", "staging", "prod"], var.environment)
    error_message = "Environment must be dev, staging, or prod."
  }
}
```

## Resource Naming

- Pattern: `<project>-<component>` (e.g., `myapp-api`, `myapp-db`)
- Consistent labels on all resources: `environment`, `app`
- Use `for_each` over `count` where possible

```hcl
locals {
  common_labels = {
    environment = var.environment
    app         = var.project_name
    managed_by  = "terraform"
  }
}
```

## Secrets

- Random generation: `random_password` resource
- Store in Secret Manager (GCP) or Secrets Manager (AWS)
- Reference with `version = "latest"`
- Never store secrets in state (use `sensitive = true`)

```hcl
resource "random_password" "db_password" {
  length  = 32
  special = true
}

resource "google_secret_manager_secret_version" "db_password" {
  secret      = google_secret_manager_secret.db_password.id
  secret_data = random_password.db_password.result
}
```

## IAM

- Least privilege: specific roles per service account
- Separate service accounts per service (API, scheduler, operations)
- `google_project_iam_member` for project-level roles
- `google_service_account_iam_member` for SA-level roles
- Impersonation for manual operations

```hcl
resource "google_service_account" "api" {
  account_id   = "${var.project_name}-api"
  display_name = "API Service Account"
}

resource "google_project_iam_member" "api_roles" {
  for_each = toset([
    "roles/cloudsql.client",
    "roles/secretmanager.secretAccessor",
  ])

  project = var.gcp_project_id
  role    = each.value
  member  = "serviceAccount:${google_service_account.api.email}"
}
```

## CI/CD with GitHub OIDC

- Workload Identity Pool + Provider
- Conditional binding: `attribute.repository == "org/repo"`
- Deployment service account with minimal permissions
- Plan on PR, apply on merge

```hcl
resource "google_iam_workload_identity_pool" "github" {
  workload_identity_pool_id = "github-actions"
  display_name              = "GitHub Actions"
}

resource "google_iam_workload_identity_pool_provider" "github" {
  workload_identity_pool_id          = google_iam_workload_identity_pool.github.workload_identity_pool_id
  workload_identity_pool_provider_id = "github-provider"
  display_name                       = "GitHub Provider"

  attribute_mapping = {
    "google.subject"       = "assertion.sub"
    "attribute.repository" = "assertion.repository"
  }

  oidc {
    issuer_uri = "https://token.actions.githubusercontent.com"
  }
}
```

## Variables

- All variables have descriptions
- Defaults where sensible
- `sensitive = true` for secrets
- Validation blocks for constrained inputs

```hcl
variable "region" {
  description = "GCP region for resource deployment"
  type        = string
  default     = "us-central1"
}

variable "db_tier" {
  description = "Cloud SQL instance tier"
  type        = string
  default     = "db-f1-micro"
}
```

## Multi-Module Composition

- `depends_on` for explicit ordering
- Module outputs as parent inputs
- Connection strings constructed in parent
- `locals` for computed values

```hcl
module "database" {
  source      = "./modules/database"
  environment = var.environment
  project_id  = var.gcp_project_id
}

module "api" {
  source          = "./modules/api"
  environment     = var.environment
  database_url    = module.database.connection_string
  depends_on      = [module.database]
}
```

## Testing

- Native `terraform test` with `.tftest.hcl` files
- `terraform validate` in CI
- Plan-based assertions
- Apply-based integration tests (when cost-effective)

```hcl
# tests/basic.tftest.hcl
run "verify_plan" {
  command = plan

  assert {
    condition     = google_cloud_run_v2_service.this.template[0].containers[0].image != ""
    error_message = "Container image must be set"
  }
}
```

## Gotchas

- Always set `disable_on_destroy = false` for API enablement resources
- Use health checks for DB connections (equivalent of `pool_pre_ping`)
- `lifecycle { prevent_destroy = true }` for critical resources (databases, state buckets)
- `.terraform.lock.hcl` should be committed to version control
- `for_each` requires a set or map -- use `toset()` to convert lists
- Avoid `count` for resources that may be reordered -- use `for_each` with stable keys
- `sensitive = true` only hides from plan output, not from state file
- State file itself contains secrets -- secure the backend bucket

## Common Mistakes (WRONG → RIGHT)

### count vs for_each for reorderable resources

```hcl
# WRONG — count uses index, reordering the list destroys/recreates resources
resource "google_project_iam_member" "roles" {
  count   = length(var.roles)
  role    = var.roles[count.index]
  member  = "serviceAccount:${var.sa_email}"
  project = var.project_id
}

# RIGHT — for_each with stable keys, safe to reorder
resource "google_project_iam_member" "roles" {
  for_each = toset(var.roles)
  role     = each.value
  member   = "serviceAccount:${var.sa_email}"
  project  = var.project_id
}
```

### Missing disable_on_destroy for API enablement

```hcl
# WRONG — destroying this resource disables the API for the entire project
resource "google_project_service" "cloud_run" {
  service = "run.googleapis.com"
}

# RIGHT — prevent API disable on resource destruction
resource "google_project_service" "cloud_run" {
  service            = "run.googleapis.com"
  disable_on_destroy = false
}
```

### sensitive = true misconception

```hcl
# WRONG — thinking sensitive hides the value from state
variable "db_password" {
  type      = string
  sensitive = true  # Only hides from plan output!
}

# RIGHT — sensitive hides from plan, but state still contains the value
# Always secure the state backend (encryption, access controls)
variable "db_password" {
  type      = string
  sensitive = true
}
# State file at gs://bucket/terraform.tfstate contains the plaintext value
# → Secure the bucket with IAM, encryption, and audit logging
```
