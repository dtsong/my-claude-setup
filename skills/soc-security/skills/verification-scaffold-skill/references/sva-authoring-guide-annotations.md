# SVA Authoring Guide — Annotation Requirements and Coverage

## Table of Contents

- [Mandatory Annotations](#1-annotation-requirements)
- [INTENT Annotation](#intent-annotation)
- [DOES NOT CHECK Annotation](#does-not-check-annotation)
- [Candidate for Review Statement](#the-candidate-for-review-statement)
- [Coverage Companion Properties](#6-coverage-companion-properties)
- [Coverage Interpretation](#coverage-interpretation)

---

## 1. Annotation Requirements

### Mandatory Annotations

Every SVA assertion template produced by this skill MUST include two annotations. These are not optional. They are not boilerplate. They must be specific to the individual assertion.

#### `// INTENT:` Annotation

**Purpose:** Explain in plain English what security property this assertion checks. Written for a reader who may not be familiar with the specific design.

**Must include:**
1. What security property is being checked
2. Under what conditions the check applies
3. What constitutes a violation
4. Why this matters (threat context)

**Example (good):**
```systemverilog
// INTENT: Checks that the IDE key register cannot be written after the
//         key_lock_bit is set. This prevents runtime modification of the
//         encryption key after the secure channel has been established.
//         A violation indicates that the key lock mechanism has been bypassed,
//         which could allow an attacker to inject a known key and decrypt
//         all traffic on the IDE stream.
```

**Example (bad):**
```systemverilog
// INTENT: Checks the key register.
// [Too vague — what about the key register? What's the security property?]
```

#### `// DOES NOT CHECK:` Annotation

**Purpose:** Explicitly declare what this assertion does NOT verify. This is the most important annotation for security because it prevents false confidence.

**Must include:**
- At least 3 specific things the assertion does not check
- Focus on security-relevant omissions, not trivial ones
- Consider: multi-step attacks, cross-module interactions, physical attacks, side channels

**Common DOES NOT CHECK items for security assertions:**

| Category | Examples |
|----------|---------|
| Multi-step attacks | "Does not check if the guard signal was legitimately asserted through the full authentication sequence" |
| Fault injection | "Does not check resilience to voltage glitching on the comparison logic" |
| Side channels | "Does not check for timing or power leakage during the comparison" |
| Cross-module | "Does not check if the input signal is correctly driven by the upstream module" |
| Reset behavior | "Does not check behavior during or immediately after reset assertion" |
| Clock domain | "Does not check metastability of signals crossing from the other clock domain" |
| Coverage gaps | "Only checks the specific transition X->Y; other transitions to Y from different states are not covered" |

**Example (good):**
```systemverilog
// DOES NOT CHECK:
//   - Whether authentication_complete was derived from a legitimate SPDM exchange
//     (this assertion only checks the signal value, not the protocol that produced it)
//   - Glitch-based attacks that briefly assert authentication_complete for less
//     than one clock cycle (assertion samples at clock edges only)
//   - Transitions to DATA_TRANSFER from states other than LOCKED (requires
//     separate assertions for each source state)
//   - Behavior during reset deassertion (disabled by disable iff)
//   - Side-channel leakage through timing of the state transition
```

**Example (bad):**
```systemverilog
// DOES NOT CHECK: Other security properties.
// [Useless — this tells the engineer nothing about specific gaps]
```

### The "Candidate for Review" Statement

Every assertion template must include this statement:
```systemverilog
// CANDIDATE FOR REVIEW: This assertion was generated by the verification-scaffold-skill.
// Verify signal names, timing, and completeness against your RTL before use.
```

This is not a disclaimer — it is a functional instruction. The engineer must review the assertion before trusting it.

---

## 6. Coverage Companion Properties

### Why Coverage Matters

An assertion that never fires is useless — it may be vacuously true because the antecedent condition never occurs. Coverage companion properties verify that the assertion's triggering condition was actually exercised during simulation.

### Standard Coverage Pattern

For every assertion, generate a cover property that tracks the antecedent:

```systemverilog
// Cover: Verify that the triggering condition occurs during simulation
c_<property_name>_trigger: cover property (
  @(posedge <clk>) disable iff (!<rst_n>)
  <antecedent>
);

// Optional: Cover the full property (antecedent AND consequent)
c_<property_name>_full: cover property (p_<property_name>);
```

### Coverage Interpretation

| Coverage Result | Interpretation | Action |
|----------------|----------------|--------|
| Antecedent covered, assertion passed | Property was tested and holds | Good — property is verified for observed scenarios |
| Antecedent NOT covered | Property was never tested | Bad — need test stimulus that triggers the antecedent |
| Assertion failed | Property violation detected | Investigate: is it a design bug or an assertion bug? |
